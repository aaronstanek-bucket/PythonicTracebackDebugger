import sys
import os

if sys.version_info.major!=3:
    print("This is Python 3 software. Please use a Python 3 interpreter.")
    exit()

def parseCall():
    if (len(sys.argv))<3:
        print("Too few arguments in call.")
        exit()
    ou = dict()
    ou["in"] = sys.argv[1]
    ou["out"] = sys.argv[2]
    ou["ow"] = False
    if len(sys.argv)>3:
        if sys.argv[3]=="ow":
            ou["ow"] = True
    return ou

def checkFiles(ins):
    if os.path.isfile(ins["in"])==False:
        print("No file at the specified input path.")
        exit()
    if ins["ow"]==False:
        if os.path.isfile(ins["out"])==True:
            print("There is a file at the specified output path.")
            print("Use \"ow\" to ignore this, and allow overwrite.")
            exit()

def loadInputFile(inpath):
    infile = open(inpath,"rb")
    data = list(infile.read())
    infile.close()
    data.append(10)
    return data

def removeComments(rawInput):
    ou = []
    in_comment = False
    in_block_comment = False
    in_quote = False
    in_char = False
    i = 0
    while i<len(rawInput):
        if in_comment:
            if rawInput[i]==13:
                in_comment = False
                ou.append(13)
                i = i+1
                continue
            if rawInput[i]==10:
                in_comment = False
                ou.append(10)
                i = i+1
                continue
            ou.append(32)
            i = i+1
            continue
        if in_block_comment:
            if rawInput[i:i+2]==[42,47]:
                in_block_comment = False
                ou.append(32)
                ou.append(32)
                i = i+2
                continue
            if rawInput[i]==13:
                ou.append(13)
                i = i+1
                continue
            if rawInput[i]==10:
                ou.append(10)
                i = i+1
                continue
            ou.append(32)
            i = i+1
            continue
        if in_quote:
            if rawInput[i:i+2]==[92,34]:
                ou.append(92)
                ou.append(34)
                i = i+2
                continue
            if rawInput[i]==34:
                in_quote = False
                ou.append(34)
                i = i+1
                continue
            ou.append(rawInput[i])
            i = i+1
            continue
        if in_char:
            if rawInput[i:i+2]==[92,39]:
                ou.append(92)
                ou.append(39)
                i = i+2
                continue
            if rawInput[i]==39:
                in_char = False
                ou.append(39)
                i = i+1
                continue
            ou.append(rawInput[i])
            i = i+1
            continue
        if rawInput[i:i+2]==[47,47]:
            in_comment = True
            ou.append(32)
            ou.append(32)
            i = i+2
            continue
        if rawInput[i:i+2]==[47,42]:
            in_block_comment = True
            ou.append(32)
            ou.append(32)
            i = i+2
            continue
        if rawInput[i]==34:
            in_quote = True
            ou.append(34)
            i = i+1
            continue
        if rawInput[i]==39:
            in_char = True
            ou.append(39)
            i = i+1
            continue
        ou.append(rawInput[i])
        i = i+1
    return ou

def gatherHeader():
    ou = [
        "// file generated by PythonicTracebackDebugger",
        "#include \"PythonicTracebackDebugger.h\""
        ]
    return ou

def makeLines(indata):
    ou = gatherHeader()
    hold = []
    i = 0
    while i<len(indata):
        eol = False
        if indata[i:i+2]==[13,10]:
            eol = True
            i = i+2
        elif indata[i]==13:
            eol = True
            i = i+1
        elif indata[i]==10:
            eol = True
            i = i+1
        if eol:
            ou.append((bytes(hold)).decode("utf8"))
            hold = []
        else:
            hold.append(indata[i])
            i = i+1
    return ou

def annotate_update(line):
    i = 0
    while (True):
        if i>=len(line):
            return False
        if line[i]==" ":
            i = i+1
            continue
        if line[i]=="   ":
            i = i+1
            continue
        break
    cho = ord(line[i])
    if ((cho>=97) and (cho<=122)):
        pass
    elif ((cho>=65) and (cho<=90)):
        pass
    elif cho==95:
        pass
    else:
        return False
    if line[i]=="e":
        if line[i:i+5]=="else ":
            return False
        if line[i:i+5]=="else{":
            return False
    elif line[i]=="c":
        if line[i:i+6]=="catch ":
            return False
        if line[i:i+6]=="catch(":
            return False
        if line[i:i+6]=="catch{":
            return False
    return True

def annotate_func(line):
    try:
        i = 0
        while ((line[i]==" ") or (line[i]=="    ")):
            i = i+1
        fname = ""
        prevWasSpace = True
        while line[i]!="(":
            if ((line[i]==" ") or (line[i]=="    ")):
                prevWasSpace = True
                i = i+1
                continue
            if prevWasSpace:
                fname = ""
                prevWasSpace = False
            fname = fname+line[i]
            i = i+1
        in_quote = False
        in_char = False
        while True:
            if in_quote:
                if line[i:i+2]=="\\\"":
                    i = i+2
                    continue
                if line[i]=="\"":
                    in_quote = False
                    i = i+1
                    continue
                i = i+1
            if in_char:
                if line[i:i+2]=="\\\'":
                    i = i+2
                    continue
                if line[i]=="\'":
                    in_quote = False
                    i = i+1
                    continue
                i = i+1
                continue
            if line[i]=="\"":
                in_quote = True
                i = i+1
                continue
            if line[i]=="\'":
                in_char = True
                i = i+1
                continue
            if line[i]==")":
                break
            i = i+1
    except:
        return {"func":0}
    try:
        i = i+1
        while ((line[i]==" ") or (line[i]=="    ")):
            i = i+1
        if line[i]=="{":
            return {"func":1,"fname":fname,"getSpot":i}
        return {"func":0}
    except:
        return {"func":2,"fname":fname}

def annotate_line(line):
    info = annotate_func(line)
    info["update"] = annotate_update(line)
    if info["func"]!=0:
        if info["fname"] in {"if","else","try","catch","for","while"}:
            info["func"] = 0
    return [line,info]

def annotate(lineInput):
    ou = []
    for x in lineInput:
        ou.append(annotate_line(x))
    return ou

def getCurlyCount(ln):
    left = 0
    right = 0
    in_quote = False
    in_char = False
    i = 0
    while i<len(ln):
        if in_quote:
            if ln[i:i+2]=="\\\"":
                i = i+2
            elif ln[i]=="\"":
                in_quote = False
                i = i+1
            else:
                i = i+1
            continue
        if in_char:
            if ln[i:i+2]=="\\\'":
                i = i+2
            elif ln[i]=="\'":
                in_quote = False
                i = i+1
            else:
                i = i+1
            continue
        if ln[i]=="\"":
            in_quote = True
            i = i+1
        elif ln[i]=="\'":
            in_char = True
            i = i+1
        elif ln[i]=="{":
            left = left+1
            i = i+1
        elif ln[i]=="}":
            right = right+1
            i = i+1
        else:
            i = i+1
    return left,right

def inject(ln,injectpoint,infile_basename,fname,gnum):
    return ln[:injectpoint]+"{PythonicTracebackDebugger::coin MY_LOCAL_FUNCTION_COIN_TEMP(\""+infile_basename+"\",\""+fname+"\","+str(gnum)+");"+ln[injectpoint+1:]

def findInjectPoint(ln):
    i = 0
    try:
        while ((ln[i]==" ") or (ln[i]=="    ")):
            i = i+1
    except:
        return -1
    if ln[i]=="{":
        return i
    return -1

def makeOutputLines(anote,infile_basename):
    ou = []
    in_function = False
    curly_count = 0
    hanging = False
    fname = ""
    ou.append(anote[0][0])
    ou.append(anote[1][0])
    for ln in range(2,len(anote)):
        gnum = ln-1
        line = anote[ln][0]
        info = anote[ln][1]
        if hanging:
            ip = findInjectPoint(line)
            if ip==-1:
                ou.append(line)
            else:
                ou.append(inject(line,ip,infile_basename,fname,gnum))
                hanging = False
            del(ip)
        else:
            if info["func"]!=0:
                in_function = True
                curly_count = 0
                if info["func"]==1:
                    ou.append(inject(line,info["getSpot"],infile_basename,info["fname"],gnum))
                else:
                    ou.append(line)
                    hanging = True
                    fname = info["fname"]
            elif info["update"]==True:
                if in_function:
                    ou.append("MY_DEBUGGING_NODE.update("+str(gnum)+");"+line)
                else:
                    ou.append(line)
            else:
                ou.append(line)
        cleft,cright = getCurlyCount(line)
        curly_count = curly_count+cleft-cright
        del(cleft)
        del(cright)
        if ((in_function==True) and (hanging==False)):
            if curly_count<=0:
                in_function = False
    return ou

def makeOutputBytes(lineOutput):
    ou = []
    for x in lineOutput:
        p = x.encode("utf8")
        for y in p:
            ou.append(y)
        ou.append(13)
        ou.append(10)
    ou = bytes(ou)
    return ou

def save(outpath,data):
    outfile = open(outpath,"wb")
    outfile.truncate(0)
    outfile.seek(0,0)
    outfile.write(data)
    outfile.close()

def main():
    ins = parseCall()
    checkFiles(ins)
    rawInput = loadInputFile(ins["in"])
    no_comment = removeComments(rawInput)
    del(rawInput)
    lineInput = makeLines(no_comment)
    del(no_comment)
    anote = annotate(lineInput)
    del(lineInput)
    infile_basename = os.path.basename(ins["in"])
    lineOutput = makeOutputLines(anote,infile_basename)
    del(anote)
    del(infile_basename)
    output_bytes = makeOutputBytes(lineOutput)
    del(lineOutput)
    save(ins["out"],output_bytes)

main()
